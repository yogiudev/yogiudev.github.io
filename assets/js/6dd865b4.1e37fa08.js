"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4192],{463:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"SOLA/guides/The Complete Guide to LangGraph_ Mastering Nodes,","title":"The Complete Guide to LangGraph_ Mastering Nodes,","description":"LangGraph has emerged as a powerful framework for building stateful, multi-agent AI applications that go far beyond simple chatbots. Unlike traditional linear workflows, LangGraph enables you to create complex, cyclical graphs where AI agents can reason, make decisions, and collaborate in sophisticated ways. This comprehensive guide will teach you everything you need to know about nodes, edges, and building real-world applications with LangGraph.","source":"@site/docs/SOLA/guides/The Complete Guide to LangGraph_ Mastering Nodes,.md","sourceDirName":"SOLA/guides","slug":"/SOLA/guides/The Complete Guide to LangGraph_ Mastering Nodes,","permalink":"/docs/SOLA/guides/The Complete Guide to LangGraph_ Mastering Nodes,","draft":false,"unlisted":false,"editUrl":"https://github.com/yogiudev/yogiudev.github.io/tree/main/docs/SOLA/guides/The Complete Guide to LangGraph_ Mastering Nodes,.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Guides","permalink":"/docs/category/guides"},"next":{"title":"Vector Database & Embeddings_ Complete Guide with","permalink":"/docs/SOLA/guides/Vector Database & Embeddings_ Complete Guide with"}}');var s=t(4848),r=t(8453);const i={},o="The Complete Guide to LangGraph: Mastering Nodes, Edges, and Real-World Workflows",l={},d=[{value:"Why LangGraph Matters for Modern AI Development",id:"why-langgraph-matters-for-modern-ai-development",level:2},{value:"Core Concepts: State, Nodes, and Edges",id:"core-concepts-state-nodes-and-edges",level:2},{value:"Understanding State in LangGraph",id:"understanding-state-in-langgraph",level:3},{value:"Defining Nodes: The Building Blocks",id:"defining-nodes-the-building-blocks",level:3},{value:"Basic Node Structure",id:"basic-node-structure",level:4},{value:"Node Types and Patterns",id:"node-types-and-patterns",level:4},{value:"Mastering Edges: Controlling Flow",id:"mastering-edges-controlling-flow",level:3},{value:"Normal Edges",id:"normal-edges",level:4},{value:"Conditional Edges",id:"conditional-edges",level:4},{value:"Real-World Use Case 1: Customer Support Bot",id:"real-world-use-case-1-customer-support-bot",level:2},{value:"State Definition",id:"state-definition",level:3},{value:"Node Implementation",id:"node-implementation",level:3},{value:"Routing Logic",id:"routing-logic",level:3},{value:"Building the Graph",id:"building-the-graph",level:3},{value:"Real-World Use Case 2: Document Processing Pipeline",id:"real-world-use-case-2-document-processing-pipeline",level:2},{value:"State Definition",id:"state-definition-1",level:3},{value:"Processing Nodes",id:"processing-nodes",level:3},{value:"Conditional Processing",id:"conditional-processing",level:3},{value:"Real-World Use Case 3: Multi-Agent Research System",id:"real-world-use-case-3-multi-agent-research-system",level:2},{value:"Multi-Agent State",id:"multi-agent-state",level:3},{value:"Agent Implementation",id:"agent-implementation",level:3},{value:"Agent Routing",id:"agent-routing",level:3},{value:"Advanced Patterns and Best Practices",id:"advanced-patterns-and-best-practices",level:2},{value:"Human-in-the-Loop Integration",id:"human-in-the-loop-integration",level:3},{value:"Implementing Human-in-the-Loop",id:"implementing-human-in-the-loop",level:3},{value:"Parallel Processing Pattern",id:"parallel-processing-pattern",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:3},{value:"Performance Optimization and Monitoring",id:"performance-optimization-and-monitoring",level:2},{value:"State Management Best Practices",id:"state-management-best-practices",level:3},{value:"Common Pitfalls and Solutions",id:"common-pitfalls-and-solutions",level:2},{value:"1. State Mutation Issues",id:"1-state-mutation-issues",level:3},{value:"2. Infinite Loops",id:"2-infinite-loops",level:3},{value:"3. Error Propagation",id:"3-error-propagation",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",section:"section",strong:"strong",sup:"sup",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{src:"https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png",class:"logo",width:"120"}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"the-complete-guide-to-langgraph-mastering-nodes-edges-and-real-world-workflows",children:"The Complete Guide to LangGraph: Mastering Nodes, Edges, and Real-World Workflows"})}),"\n",(0,s.jsx)(n.p,{children:"LangGraph has emerged as a powerful framework for building stateful, multi-agent AI applications that go far beyond simple chatbots. Unlike traditional linear workflows, LangGraph enables you to create complex, cyclical graphs where AI agents can reason, make decisions, and collaborate in sophisticated ways. This comprehensive guide will teach you everything you need to know about nodes, edges, and building real-world applications with LangGraph."}),"\n",(0,s.jsx)(n.h2,{id:"why-langgraph-matters-for-modern-ai-development",children:"Why LangGraph Matters for Modern AI Development"}),"\n",(0,s.jsxs)(n.p,{children:["Traditional AI applications often follow linear, predetermined paths that struggle with complex, real-world scenarios. LangGraph addresses this limitation by modeling workflows as graphs where each node represents a specific function or agent, and edges define the flow of information and control between them ",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The key advantages of LangGraph include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stateful workflows"})," that maintain context across multiple interactions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conditional routing"})," that adapts based on dynamic conditions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Multi-agent coordination"})," for complex problem-solving"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Human-in-the-loop integration"})," for oversight and control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error handling and recovery"})," mechanisms"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts-state-nodes-and-edges",children:"Core Concepts: State, Nodes, and Edges"}),"\n",(0,s.jsx)(n.h3,{id:"understanding-state-in-langgraph",children:"Understanding State in LangGraph"}),"\n",(0,s.jsxs)(n.p,{children:["State in LangGraph is the shared data structure that represents the current snapshot of your application. It acts as the communication medium between nodes, allowing them to share information and coordinate their actions ",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-4",id:"user-content-fnref-4","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),"."]}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[Initial State] --\x3e B[Node 1]\n    B --\x3e C[Updated State 1]\n    C --\x3e D[Node 2]\n    D --\x3e E[Updated State 2]\n    E --\x3e F[Node 3]\n    F --\x3e G[Final State]\n    \n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style B fill:#fff3e0\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#e8f5e8\n    style F fill:#fff3e0"}),"\n",(0,s.jsx)(n.p,{children:"Here's how to define state effectively:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from typing import Annotated, TypedDict, List\nfrom langgraph.graph.message import add_messages\nfrom operator import add\n\nclass ApplicationState(TypedDict):\n    messages: Annotated[list, add_messages]  # Append messages\n    user_data: dict                          # Override completely\n    processing_steps: Annotated[List[str], add]  # Accumulate steps\n    current_status: str                      # Track current state\n    error_count: int                         # Simple integer field\n"})}),"\n",(0,s.jsx)(n.h3,{id:"defining-nodes-the-building-blocks",children:"Defining Nodes: The Building Blocks"}),"\n",(0,s.jsxs)(n.p,{children:["Nodes are Python functions that perform specific tasks within your workflow. They receive the current state as input and return updates to that state ",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-4",id:"user-content-fnref-4-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"basic-node-structure",children:"Basic Node Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def my_node(state: ApplicationState) -> dict:\n    """Process the current state and return updates"""\n    # Your processing logic here\n    result = process_data(state["user_data"])\n    \n    return {\n        "processing_steps": ["Data processed"],\n        "current_status": "completed",\n        "result": result\n    }\n'})}),"\n",(0,s.jsx)(n.h4,{id:"node-types-and-patterns",children:"Node Types and Patterns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"1. Processing Nodes"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def analyze_text(state: ApplicationState) -> dict:\n    """Analyze text content and extract insights"""\n    messages = state["messages"]\n    last_message = messages[-1] if messages else None\n    \n    if last_message:\n        # Simulate text analysis\n        sentiment = "positive" if "good" in last_message.content.lower() else "neutral"\n        keywords = extract_keywords(last_message.content)\n        \n        return {\n            "analysis_results": {\n                "sentiment": sentiment,\n                "keywords": keywords,\n                "confidence": 0.85\n            },\n            "processing_steps": ["Text analysis completed"]\n        }\n    \n    return {"processing_steps": ["No text to analyze"]}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"2. Decision Nodes"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def evaluate_risk(state: ApplicationState) -> dict:\n    """Evaluate risk based on current data"""\n    user_data = state["user_data"]\n    \n    risk_score = calculate_risk(user_data)\n    risk_level = "high" if risk_score > 0.7 else "medium" if risk_score > 0.3 else "low"\n    \n    return {\n        "risk_assessment": {\n            "score": risk_score,\n            "level": risk_level,\n            "recommendation": get_recommendation(risk_level)\n        },\n        "current_status": f"risk_evaluated_{risk_level}"\n    }\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"3. Integration Nodes"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def fetch_external_data(state: ApplicationState) -> dict:\n    """Fetch data from external APIs"""\n    user_id = state["user_data"].get("user_id")\n    \n    try:\n        external_data = api_client.get_user_profile(user_id)\n        return {\n            "external_data": external_data,\n            "processing_steps": ["External data fetched successfully"],\n            "current_status": "data_enriched"\n        }\n    except Exception as e:\n        return {\n            "processing_steps": [f"External data fetch failed: {str(e)}"],\n            "current_status": "data_fetch_failed",\n            "error_count": state.get("error_count", 0) + 1\n        }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mastering-edges-controlling-flow",children:"Mastering Edges: Controlling Flow"}),"\n",(0,s.jsxs)(n.p,{children:["Edges define how your application flows from one node to another. LangGraph supports several types of edges for different scenarios ",(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-4",id:"user-content-fnref-4-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"4"})}),(0,s.jsx)(n.sup,{children:(0,s.jsx)(n.a,{href:"#user-content-fn-5",id:"user-content-fnref-5-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"5"})}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"normal-edges",children:"Normal Edges"}),"\n",(0,s.jsx)(n.p,{children:"Direct connections between nodes for sequential processing:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'builder.add_edge("process_input", "analyze_data")\nbuilder.add_edge("analyze_data", "generate_response")\n'})}),"\n",(0,s.jsx)(n.h4,{id:"conditional-edges",children:"Conditional Edges"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic routing based on state conditions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def route_based_on_analysis(state: ApplicationState) -> str:\n    """Route based on analysis results"""\n    analysis = state.get("analysis_results", {})\n    sentiment = analysis.get("sentiment", "neutral")\n    \n    if sentiment == "negative":\n        return "handle_complaint"\n    elif sentiment == "positive":\n        return "process_feedback"\n    else:\n        return "general_response"\n\nbuilder.add_conditional_edges(\n    "analyze_text",\n    route_based_on_analysis,\n    {\n        "handle_complaint": "complaint_handler",\n        "process_feedback": "feedback_processor",\n        "general_response": "general_responder"\n    }\n)\n'})}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[START] --\x3e B[Input Processing]\n    B --\x3e C{Conditional<br/>Logic}\n    C --\x3e|Negative| D[Handle Complaint]\n    C --\x3e|Positive| E[Process Feedback]\n    C --\x3e|Neutral| F[General Response]\n    D --\x3e G[END]\n    E --\x3e G\n    F --\x3e G\n    \n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style B fill:#fff3e0\n    style C fill:#ffebee\n    style D fill:#ffcdd2\n    style E fill:#e8f5e8\n    style F fill:#fff3e0"}),"\n",(0,s.jsx)(n.h2,{id:"real-world-use-case-1-customer-support-bot",children:"Real-World Use Case 1: Customer Support Bot"}),"\n",(0,s.jsx)(n.p,{children:"Let's build a comprehensive customer support bot that demonstrates advanced LangGraph patterns:"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[START] --\x3e B[Greet Customer]\n    B --\x3e C[Classify Issue]\n    C --\x3e D{Issue Priority<br/>& Type}\n    D --\x3e|High Priority| E[Escalate to Human]\n    D --\x3e|Medium/Low| F[Attempt Resolution]\n    F --\x3e G{Resolution<br/>Successful?}\n    G --\x3e|Yes| H[END]\n    G --\x3e|No| E\n    E --\x3e H\n    \n    style A fill:#e1f5fe\n    style H fill:#f3e5f5\n    style B fill:#fff3e0\n    style C fill:#fff3e0\n    style D fill:#ffebee\n    style E fill:#ffcdd2\n    style F fill:#fff3e0\n    style G fill:#ffebee"}),"\n",(0,s.jsx)(n.h3,{id:"state-definition",children:"State Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from typing import Annotated, TypedDict\nfrom langgraph.graph import StateGraph, START, END, add_messages\nfrom langchain_core.messages import HumanMessage, AIMessage\n\nclass CustomerSupportState(TypedDict):\n    messages: Annotated[list, add_messages]\n    customer_id: str\n    issue_type: str\n    priority: str\n    resolved: bool\n    escalation_reason: str\n"})}),"\n",(0,s.jsx)(n.h3,{id:"node-implementation",children:"Node Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def greet_customer(state: CustomerSupportState):\n    """Initial greeting and customer identification"""\n    last_message = state["messages"][-1]\n    \n    # Extract customer ID (simplified for demo)\n    customer_id = extract_customer_id(last_message.content)\n    \n    response = AIMessage(\n        content=f"Hello! I\'m here to help you today. I see you\'re customer {customer_id}. How can I assist you?"\n    )\n    \n    return {\n        "messages": [response],\n        "customer_id": customer_id,\n        "priority": "medium"\n    }\n\ndef classify_issue(state: CustomerSupportState):\n    """Classify customer issue and set priority"""\n    last_message = state["messages"][-1]\n    content = last_message.content.lower()\n    \n    # Classification logic\n    if any(word in content for word in ["urgent", "broken", "not working"]):\n        issue_type = "technical"\n        priority = "high"\n    elif any(word in content for word in ["bill", "charge", "payment"]):\n        issue_type = "billing"\n        priority = "high"\n    elif any(word in content for word in ["cancel", "refund"]):\n        issue_type = "cancellation"\n        priority = "medium"\n    else:\n        issue_type = "general"\n        priority = "low"\n    \n    response = AIMessage(\n        content=f"I understand this is a {issue_type} issue. Let me help you with that."\n    )\n    \n    return {\n        "messages": [response],\n        "issue_type": issue_type,\n        "priority": priority\n    }\n\ndef resolve_issue(state: CustomerSupportState):\n    """Attempt to resolve the customer\'s issue"""\n    issue_type = state["issue_type"]\n    \n    solutions = {\n        "technical": "Let me walk you through the troubleshooting steps...",\n        "billing": "I\'ve reviewed your account and can process a refund...",\n        "cancellation": "I can help you with the cancellation process...",\n        "general": "I\'ll be happy to help with your inquiry..."\n    }\n    \n    response = AIMessage(content=solutions.get(issue_type, "Let me find the best solution."))\n    \n    # Simulate resolution success/failure\n    success_rate = {"technical": 0.7, "billing": 0.9, "cancellation": 0.8, "general": 0.95}\n    resolved = random.random() < success_rate.get(issue_type, 0.8)\n    \n    return {\n        "messages": [response],\n        "resolved": resolved\n    }\n\ndef escalate_to_human(state: CustomerSupportState):\n    """Escalate to human agent"""\n    escalation_reason = state.get("escalation_reason", "Complex issue requiring human attention")\n    \n    response = AIMessage(\n        content=f"I\'m escalating your issue to a specialist. Reason: {escalation_reason}. Please hold."\n    )\n    \n    return {\n        "messages": [response],\n        "resolved": True  # Escalation counts as resolution\n    }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"routing-logic",children:"Routing Logic"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def should_escalate(state: CustomerSupportState) -> str:\n    """Determine if issue should be escalated"""\n    priority = state["priority"]\n    resolved = state.get("resolved", False)\n    \n    if priority == "high" and not resolved:\n        return "escalate"\n    elif resolved:\n        return "end"\n    else:\n        return "resolve"\n\ndef post_resolution_routing(state: CustomerSupportState) -> str:\n    """Route after resolution attempt"""\n    resolved = state.get("resolved", False)\n    \n    if resolved:\n        return "end"\n    else:\n        return "escalate"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"building-the-graph",children:"Building the Graph"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def build_customer_support_bot():\n    builder = StateGraph(CustomerSupportState)\n    \n    # Add nodes\n    builder.add_node("greet", greet_customer)\n    builder.add_node("classify", classify_issue)\n    builder.add_node("resolve", resolve_issue)\n    builder.add_node("escalate", escalate_to_human)\n    \n    # Add edges\n    builder.add_edge(START, "greet")\n    builder.add_edge("greet", "classify")\n    \n    builder.add_conditional_edges(\n        "classify",\n        should_escalate,\n        {\n            "resolve": "resolve",\n            "escalate": "escalate",\n            "end": END\n        }\n    )\n    \n    builder.add_conditional_edges(\n        "resolve",\n        post_resolution_routing,\n        {\n            "escalate": "escalate",\n            "end": END\n        }\n    )\n    \n    builder.add_edge("escalate", END)\n    \n    return builder.compile()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-use-case-2-document-processing-pipeline",children:"Real-World Use Case 2: Document Processing Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"Document processing showcases LangGraph's ability to handle complex, multi-step workflows with error handling and quality control:"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[START] --\x3e B[Extract Text]\n    B --\x3e C[Analyze Content]\n    C --\x3e D[Validate Data]\n    D --\x3e E{Validation<br/>Results}\n    E --\x3e|>30% Failed| F[Reprocess Failed]\n    E --\x3e|<30% Failed| G[Generate Report]\n    F --\x3e G\n    G --\x3e H[END]\n    \n    style A fill:#e1f5fe\n    style H fill:#f3e5f5\n    style B fill:#fff3e0\n    style C fill:#fff3e0\n    style D fill:#fff3e0\n    style E fill:#ffebee\n    style F fill:#fff8e1\n    style G fill:#e8f5e8"}),"\n",(0,s.jsx)(n.h3,{id:"state-definition-1",children:"State Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from typing import List, Dict\nfrom operator import add\n\nclass DocumentProcessingState(TypedDict):\n    documents: List[str]\n    processed_documents: Annotated[List[dict], add]\n    extracted_data: Annotated[List[dict], add]\n    validation_results: Annotated[List[dict], add]\n    failed_documents: List[str]\n    final_report: str\n    processing_stats: dict\n"})}),"\n",(0,s.jsx)(n.h3,{id:"processing-nodes",children:"Processing Nodes"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def extract_text_node(state: DocumentProcessingState):\n    """Extract text from documents"""\n    documents = state["documents"]\n    processed_docs = []\n    \n    for i, doc in enumerate(documents):\n        try:\n            # Simulate text extraction\n            extracted_text = extract_text_from_document(doc)\n            processed_docs.append({\n                "document_id": i+1,\n                "original_name": doc,\n                "extracted_text": extracted_text,\n                "word_count": len(extracted_text.split()),\n                "extraction_confidence": 0.95\n            })\n        except Exception as e:\n            processed_docs.append({\n                "document_id": i+1,\n                "original_name": doc,\n                "error": str(e),\n                "extraction_confidence": 0.0\n            })\n    \n    return {"processed_documents": processed_docs}\n\ndef analyze_content_node(state: DocumentProcessingState):\n    """Analyze content and extract structured data"""\n    processed_docs = state["processed_documents"]\n    extracted_data = []\n    \n    for doc in processed_docs:\n        if doc.get("error"):\n            continue\n            \n        # Simulate content analysis\n        analysis = {\n            "document_id": doc["document_id"],\n            "sentiment": analyze_sentiment(doc["extracted_text"]),\n            "key_topics": extract_topics(doc["extracted_text"]),\n            "entities": extract_entities(doc["extracted_text"]),\n            "confidence_score": calculate_confidence(doc["extracted_text"])\n        }\n        extracted_data.append(analysis)\n    \n    return {"extracted_data": extracted_data}\n\ndef validate_data_node(state: DocumentProcessingState):\n    """Validate extracted data for quality"""\n    extracted_data = state["extracted_data"]\n    validation_results = []\n    \n    for data in extracted_data:\n        validation = {\n            "document_id": data["document_id"],\n            "validation_passed": data["confidence_score"] > 0.8,\n            "issues": get_validation_issues(data),\n            "quality_score": data["confidence_score"]\n        }\n        validation_results.append(validation)\n    \n    return {"validation_results": validation_results}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"conditional-processing",children:"Conditional Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def should_reprocess(state: DocumentProcessingState) -> str:\n    """Determine if reprocessing is needed"""\n    validation_results = state["validation_results"]\n    \n    if not validation_results:\n        return "generate_report"\n    \n    failed_count = sum(1 for v in validation_results if not v["validation_passed"])\n    failure_rate = failed_count / len(validation_results)\n    \n    if failure_rate > 0.3:  # More than 30% failed\n        return "reprocess"\n    else:\n        return "generate_report"\n\ndef reprocess_failed_node(state: DocumentProcessingState):\n    """Reprocess failed documents with enhanced parameters"""\n    validation_results = state["validation_results"]\n    failed_docs = [v["document_id"] for v in validation_results if not v["validation_passed"]]\n    \n    # Simulate reprocessing with better parameters\n    updated_validations = []\n    for validation in validation_results:\n        if validation["document_id"] in failed_docs:\n            # Improve validation results through reprocessing\n            validation["validation_passed"] = True\n            validation["quality_score"] = min(validation["quality_score"] + 0.2, 1.0)\n            validation["issues"] = []\n        updated_validations.append(validation)\n    \n    return {\n        "validation_results": updated_validations,\n        "failed_documents": failed_docs\n    }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-use-case-3-multi-agent-research-system",children:"Real-World Use Case 3: Multi-Agent Research System"}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates how multiple specialized agents can collaborate on complex research tasks:"}),"\n",(0,s.jsx)(n.mermaid,{value:'graph TD\n    A[START] --\x3e B[Research Coordinator]\n    B --\x3e C[Web Researcher]\n    C --\x3e D[Academic Researcher]\n    D --\x3e E[Data Analyst]\n    E --\x3e F[Report Writer]\n    F --\x3e G[END]\n    \n    subgraph "Agent Roles"\n        B\n        C\n        D\n        E\n        F\n    end\n    \n    style A fill:#e1f5fe\n    style G fill:#f3e5f5\n    style B fill:#e3f2fd\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec\n    style F fill:#f1f8e9'}),"\n",(0,s.jsx)(n.h3,{id:"multi-agent-state",children:"Multi-Agent State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class ResearchState(TypedDict):\n    messages: Annotated[list, add_messages]\n    research_query: str\n    research_plan: dict\n    web_sources: Annotated[List[dict], add]\n    academic_sources: Annotated[List[dict], add]\n    analysis_results: Annotated[List[dict], add]\n    final_report: str\n    current_agent: str\n    agent_handoffs: Annotated[List[dict], add]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"agent-implementation",children:"Agent Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def research_coordinator(state: ResearchState):\n    """Plan and coordinate the research process"""\n    query = state["research_query"]\n    \n    research_plan = {\n        "query": query,\n        "methodology": "Multi-agent collaborative research",\n        "agents": ["web_researcher", "academic_researcher", "data_analyst", "report_writer"],\n        "timeline": "Estimated 30 minutes",\n        "success_criteria": "Comprehensive report with multiple source types"\n    }\n    \n    handoff = {\n        "from_agent": "coordinator",\n        "to_agent": "web_researcher",\n        "context": f"Research query: {query}",\n        "timestamp": "2024-01-01T10:00:00Z"\n    }\n    \n    return {\n        "messages": [AIMessage(content=f"Research plan created for: {query}")],\n        "research_plan": research_plan,\n        "current_agent": "web_researcher",\n        "agent_handoffs": [handoff]\n    }\n\ndef web_researcher(state: ResearchState):\n    """Conduct web research"""\n    query = state["research_query"]\n    \n    web_sources = conduct_web_search(query)\n    \n    handoff = {\n        "from_agent": "web_researcher",\n        "to_agent": "academic_researcher",\n        "context": f"Found {len(web_sources)} web sources",\n        "timestamp": "2024-01-01T10:10:00Z"\n    }\n    \n    return {\n        "messages": [AIMessage(content=f"Web research completed: {len(web_sources)} sources found")],\n        "web_sources": web_sources,\n        "current_agent": "academic_researcher",\n        "agent_handoffs": [handoff]\n    }\n\ndef academic_researcher(state: ResearchState):\n    """Conduct academic research"""\n    query = state["research_query"]\n    \n    academic_sources = conduct_academic_search(query)\n    \n    handoff = {\n        "from_agent": "academic_researcher",\n        "to_agent": "data_analyst",\n        "context": f"Found {len(academic_sources)} academic sources",\n        "timestamp": "2024-01-01T10:20:00Z"\n    }\n    \n    return {\n        "messages": [AIMessage(content=f"Academic research completed: {len(academic_sources)} sources found")],\n        "academic_sources": academic_sources,\n        "current_agent": "data_analyst",\n        "agent_handoffs": [handoff]\n    }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"agent-routing",children:"Agent Routing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def route_to_next_agent(state: ResearchState) -> str:\n    """Route to the next agent in the research pipeline"""\n    current_agent = state.get("current_agent", "coordinator")\n    \n    agent_flow = {\n        "coordinator": "web_researcher",\n        "web_researcher": "academic_researcher",\n        "academic_researcher": "data_analyst",\n        "data_analyst": "report_writer",\n        "report_writer": "end"\n    }\n    \n    return agent_flow.get(current_agent, "end")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-patterns-and-best-practices",children:"Advanced Patterns and Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"human-in-the-loop-integration",children:"Human-in-the-Loop Integration"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[START] --\x3e B[AI Agent Processing]\n    B --\x3e C{Requires Human<br/>Approval?}\n    C --\x3e|Yes| D[Interrupt & Wait]\n    C --\x3e|No| E[Continue Processing]\n    D --\x3e F[Human Review]\n    F --\x3e G{Approved?}\n    G --\x3e|Yes| E\n    G --\x3e|No| H[Revise & Retry]\n    H --\x3e B\n    E --\x3e I[Complete Task]\n    I --\x3e J[END]\n    \n    style A fill:#e1f5fe\n    style J fill:#f3e5f5\n    style B fill:#fff3e0\n    style C fill:#ffebee\n    style D fill:#fff8e1\n    style E fill:#fff3e0\n    style F fill:#e3f2fd\n    style G fill:#ffebee\n    style H fill:#ffcdd2\n    style I fill:#e8f5e8"}),"\n",(0,s.jsx)(n.h3,{id:"implementing-human-in-the-loop",children:"Implementing Human-in-the-Loop"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from langgraph.types import interrupt\n\ndef process_with_approval(state: ApplicationState):\n    """Process with human approval checkpoint"""\n    sensitive_action = state.get("pending_action")\n    \n    if requires_human_approval(sensitive_action):\n        # Interrupt execution and wait for human input\n        human_decision = interrupt({\n            "action": sensitive_action,\n            "context": state.get("context", {}),\n            "recommendation": "Approve",\n            "risk_level": "Medium"\n        })\n        \n        if human_decision.get("approved"):\n            return execute_action(sensitive_action)\n        else:\n            return {\n                "status": "rejected",\n                "reason": human_decision.get("reason", "Human rejected")\n            }\n    \n    return execute_action(sensitive_action)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"parallel-processing-pattern",children:"Parallel Processing Pattern"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[START] --\x3e B[Input Processing]\n    B --\x3e C[Split Tasks]\n    C --\x3e D[Task 1]\n    C --\x3e E[Task 2]\n    C --\x3e F[Task 3]\n    D --\x3e G[Merge Results]\n    E --\x3e G\n    F --\x3e G\n    G --\x3e H[Final Processing]\n    H --\x3e I[END]\n    \n    style A fill:#e1f5fe\n    style I fill:#f3e5f5\n    style B fill:#fff3e0\n    style C fill:#ffebee\n    style D fill:#e8f5e8\n    style E fill:#e8f5e8\n    style F fill:#e8f5e8\n    style G fill:#fff3e0\n    style H fill:#fff3e0"}),"\n",(0,s.jsx)(n.h3,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def robust_processing_node(state: ApplicationState):\n    """Node with comprehensive error handling"""\n    try:\n        result = perform_complex_operation(state)\n        return {\n            "result": result,\n            "status": "success",\n            "processing_steps": ["Operation completed successfully"]\n        }\n    except RetryableError as e:\n        retry_count = state.get("retry_count", 0)\n        if retry_count < 3:\n            return {\n                "status": "retry",\n                "retry_count": retry_count + 1,\n                "error_message": str(e)\n            }\n        else:\n            return {\n                "status": "failed",\n                "error_message": f"Max retries exceeded: {str(e)}"\n            }\n    except CriticalError as e:\n        return {\n            "status": "critical_failure",\n            "error_message": str(e),\n            "requires_intervention": True\n        }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization-and-monitoring",children:"Performance Optimization and Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"state-management-best-practices",children:"State Management Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Use Appropriate Reducers"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# For accumulating data\nprocessing_log: Annotated[List[str], add]\n\n# For maintaining latest value\ncurrent_status: str\n\n# For message handling\nmessages: Annotated[list, add_messages]\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Implement Caching"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from langgraph.cache.memory import InMemoryCache\nfrom langgraph.types import CachePolicy\n\ndef expensive_computation(state: ApplicationState):\n    # Expensive operation\n    return {"result": complex_calculation(state["data"])}\n\nbuilder.add_node(\n    "expensive_node", \n    expensive_computation,\n    cache_policy=CachePolicy(ttl=300)  # 5 minutes\n)\n\ngraph = builder.compile(cache=InMemoryCache())\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"3",children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Monitor Performance"})}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import time\nfrom typing import Dict, Any\n\ndef monitoring_wrapper(func):\n    def wrapper(state: Dict[str, Any]) -> Dict[str, Any]:\n        start_time = time.time()\n        result = func(state)\n        execution_time = time.time() - start_time\n        \n        # Add monitoring data\n        result["execution_metrics"] = {\n            "node_name": func.__name__,\n            "execution_time": execution_time,\n            "timestamp": time.time()\n        }\n        \n        return result\n    return wrapper\n'})}),"\n",(0,s.jsx)(n.h2,{id:"common-pitfalls-and-solutions",children:"Common Pitfalls and Solutions"}),"\n",(0,s.jsx)(n.h3,{id:"1-state-mutation-issues",children:"1. State Mutation Issues"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Accidentally mutating state instead of returning updates\n",(0,s.jsx)(n.strong,{children:"Solution"}),": Always return new objects"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# \u274c Wrong - mutates state\ndef bad_node(state: ApplicationState):\n    state["data"].append("new_item")\n    return state\n\n# \u2705 Correct - returns updates\ndef good_node(state: ApplicationState):\n    return {"data": state["data"] + ["new_item"]}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-infinite-loops",children:"2. Infinite Loops"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Conditional edges creating cycles without termination\n",(0,s.jsx)(n.strong,{children:"Solution"}),": Include termination conditions and recursion limits"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def safe_routing(state: ApplicationState) -> str:\n    iteration_count = state.get("iteration_count", 0)\n    \n    if iteration_count > 10:\n        return "end"  # Force termination\n    \n    # Normal routing logic\n    if needs_processing(state):\n        return "process"\n    else:\n        return "end"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-error-propagation",children:"3. Error Propagation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Problem"}),": Errors in one node breaking the entire workflow\n",(0,s.jsx)(n.strong,{children:"Solution"}),": Implement error boundaries"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def error_boundary_node(state: ApplicationState):\n    try:\n        return risky_operation(state)\n    except Exception as e:\n        return {\n            "error": str(e),\n            "status": "error",\n            "fallback_used": True\n        }\n'})}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"LangGraph represents a paradigm shift in AI application development, enabling the creation of sophisticated, stateful workflows that can handle complex real-world scenarios. By mastering nodes, edges, and state management, you can build applications that are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resilient"})," through error handling and recovery mechanisms"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalable"})," via modular design and parallel processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainable"})," with clear separation of concerns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Adaptable"})," through conditional routing and dynamic behavior"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The examples in this guide demonstrate practical patterns you can adapt for your specific use cases. Whether you're building customer support systems, document processing pipelines, or multi-agent research tools, LangGraph provides the flexibility and power to create truly intelligent applications."}),"\n",(0,s.jsx)(n.p,{children:"Start with simple workflows and gradually add complexity as you become more comfortable with the framework. Remember that the key to successful LangGraph applications lies in thoughtful state design, robust error handling, and clear separation of responsibilities between nodes."}),"\n","\n",(0,s.jsxs)(n.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsx)(n.h2,{className:"sr-only",id:"footnote-label",children:"Footnotes"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://datasciencedojo.com/blog/langgraph-tutorial/",children:"https://datasciencedojo.com/blog/langgraph-tutorial/"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-1","data-footnote-backref":"","aria-label":"Back to reference 1",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://blog.langchain.dev/langgraph/",children:"https://blog.langchain.dev/langgraph/"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-2","data-footnote-backref":"","aria-label":"Back to reference 2",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-3",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://realpython.com/langgraph-python/",children:"https://realpython.com/langgraph-python/"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-3","data-footnote-backref":"","aria-label":"Back to reference 3",className:"data-footnote-backref",children:"\u21a9"})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-4",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://langchain-ai.github.io/langgraph/concepts/low_level/",children:"https://langchain-ai.github.io/langgraph/concepts/low_level/"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-4","data-footnote-backref":"","aria-label":"Back to reference 4",className:"data-footnote-backref",children:"\u21a9"})," ",(0,s.jsxs)(n.a,{href:"#user-content-fnref-4-2","data-footnote-backref":"","aria-label":"Back to reference 4-2",className:"data-footnote-backref",children:["\u21a9",(0,s.jsx)(n.sup,{children:"2"})]})," ",(0,s.jsxs)(n.a,{href:"#user-content-fnref-4-3","data-footnote-backref":"","aria-label":"Back to reference 4-3",className:"data-footnote-backref",children:["\u21a9",(0,s.jsx)(n.sup,{children:"3"})]})]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{id:"user-content-fn-5",children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://langchain-ai.github.io/langgraph/concepts/",children:"https://langchain-ai.github.io/langgraph/concepts/"})," ",(0,s.jsx)(n.a,{href:"#user-content-fnref-5","data-footnote-backref":"","aria-label":"Back to reference 5",className:"data-footnote-backref",children:"\u21a9"})," ",(0,s.jsxs)(n.a,{href:"#user-content-fnref-5-2","data-footnote-backref":"","aria-label":"Back to reference 5-2",className:"data-footnote-backref",children:["\u21a9",(0,s.jsx)(n.sup,{children:"2"})]})," ",(0,s.jsxs)(n.a,{href:"#user-content-fnref-5-3","data-footnote-backref":"","aria-label":"Back to reference 5-3",className:"data-footnote-backref",children:["\u21a9",(0,s.jsx)(n.sup,{children:"3"})]})]}),"\n"]}),"\n"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);