"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3195],{8130:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"SOLA/NLP-Driven API Integration for ITSM Ticket Creatio","title":"NLP-Driven API Integration for ITSM Ticket Creatio","description":"System Overview","source":"@site/docs/SOLA/NLP-Driven API Integration for ITSM Ticket Creatio.md","sourceDirName":"SOLA","slug":"/SOLA/NLP-Driven API Integration for ITSM Ticket Creatio","permalink":"/docs/SOLA/NLP-Driven API Integration for ITSM Ticket Creatio","draft":false,"unlisted":false,"editUrl":"https://github.com/yogiudev/yogiudev.github.io/tree/main/docs/SOLA/NLP-Driven API Integration for ITSM Ticket Creatio.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Generate Queries from Team Metadata","permalink":"/docs/SOLA/prompts/team_query"}}');var s=t(4848),r=t(8453);const o={},a="NLP-Driven API Integration for ITSM Ticket Creation",l={},d=[{value:"System Overview",id:"system-overview",level:2},{value:"Architecture Flow",id:"architecture-flow",level:2},{value:"Vector Database Schema (Qdrant)",id:"vector-database-schema-qdrant",level:2},{value:"Core Functions",id:"core-functions",level:2},{value:"1. Intent Extraction &amp; Entity Recognition",id:"1-intent-extraction--entity-recognition",level:3},{value:"2. Context Management",id:"2-context-management",level:3},{value:"3. API Schema Validator",id:"3-api-schema-validator",level:3},{value:"4. ITSM API Client",id:"4-itsm-api-client",level:3},{value:"5. Conversation Handler",id:"5-conversation-handler",level:3},{value:"Implementation Steps",id:"implementation-steps",level:2},{value:"<strong>Step 1: Setup Vector Database</strong>",id:"step-1-setup-vector-database",level:3},{value:"<strong>Step 2: Implement Core Functions</strong>",id:"step-2-implement-core-functions",level:3},{value:"<strong>Step 3: Integration &amp; Testing</strong>",id:"step-3-integration--testing",level:3},{value:"<strong>Step 4: Optimization</strong>",id:"step-4-optimization",level:3},{value:"Example Conversation Flow",id:"example-conversation-flow",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)("img",{src:"https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png",class:"logo",width:"120"}),"\n",(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nlp-driven-api-integration-for-itsm-ticket-creation",children:"NLP-Driven API Integration for ITSM Ticket Creation"})}),"\n",(0,s.jsx)(n.h2,{id:"system-overview",children:"System Overview"}),"\n",(0,s.jsx)(n.p,{children:"This solution creates an intelligent conversational interface that extracts user intent from natural language queries and automatically calls appropriate ITSM APIs to create tickets. The system handles complex scenarios with required/optional fields, dynamic option selection, and error handling."}),"\n",(0,s.jsx)(n.h2,{id:"architecture-flow",children:"Architecture Flow"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\n    A[User Query: My printer is not working] --\x3e B[NLP Intent Extraction]\n    B --\x3e C[Query Vector Store]\n    C --\x3e D[Retrieve API Schema & Options]\n    D --\x3e E[Extract Required Fields]\n    E --\x3e F{All Required Fields Present?}\n    F --\x3e|No| G[Ask User for Missing Fields]\n    F --\x3e|Yes| H[Build Request Body]\n    G --\x3e I[Update Context Vector]\n    I --\x3e H\n    H --\x3e J[Call ITSM API]\n    J --\x3e K{API Success?}\n    K --\x3e|No| L[Parse Error & Ask User]\n    K --\x3e|Yes| M[Return Ticket ID]\n    L --\x3e G\n    M --\x3e N[Store Conversation Context]\n"}),"\n",(0,s.jsx)(n.h2,{id:"vector-database-schema-qdrant",children:"Vector Database Schema (Qdrant)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Vector collections structure\ncollections = {\n    "api_schemas": {\n        "vector_size": 384,\n        "payload": {\n            "endpoint": "string",\n            "method": "string", \n            "required_fields": ["array"],\n            "optional_fields": ["array"],\n            "field_options": "dict"\n        }\n    },\n    "conversation_context": {\n        "vector_size": 384,\n        "payload": {\n            "session_id": "string",\n            "extracted_entities": "dict",\n            "pending_fields": ["array"],\n            "api_endpoint": "string"\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"core-functions",children:"Core Functions"}),"\n",(0,s.jsx)(n.h3,{id:"1-intent-extraction--entity-recognition",children:"1. Intent Extraction & Entity Recognition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from sentence_transformers import SentenceTransformer\nfrom qdrant_client import QdrantClient\nimport json\n\nclass IntentExtractor:\n    def __init__(self):\n        self.model = SentenceTransformer(\'all-MiniLM-L6-v2\')\n        self.qdrant = QdrantClient(host="localhost", port=6333)\n    \n    def extract_intent(self, user_query, session_id):\n        """Extract intent and entities from user query"""\n        query_embedding = self.model.encode(user_query)\n        \n        # Search for matching API schema\n        results = self.qdrant.search(\n            collection_name="api_schemas",\n            query_vector=query_embedding,\n            limit=1\n        )\n        \n        if results:\n            api_schema = results[0].payload\n            entities = self._extract_entities(user_query, api_schema)\n            \n            return {\n                "intent": "create_ticket",\n                "api_endpoint": api_schema["endpoint"],\n                "entities": entities,\n                "schema": api_schema\n            }\n        \n        return None\n    \n    def _extract_entities(self, query, schema):\n        """Extract entities using simple pattern matching"""\n        entities = {}\n        \n        # Basic entity extraction patterns\n        patterns = {\n            "issue_type": ["printer", "laptop", "network", "software"],\n            "priority": ["urgent", "high", "medium", "low"],\n            "description": query  # Full query as description\n        }\n        \n        for field, options in patterns.items():\n            if field == "description":\n                entities[field] = query\n            else:\n                for option in options:\n                    if option.lower() in query.lower():\n                        entities[field] = option\n                        break\n        \n        return entities\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-context-management",children:"2. Context Management"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ContextManager:\n    def __init__(self, qdrant_client):\n        self.qdrant = qdrant_client\n        self.model = SentenceTransformer(\'all-MiniLM-L6-v2\')\n    \n    def save_context(self, session_id, entities, pending_fields, api_endpoint):\n        """Save conversation context to vector store"""\n        context_text = f"Session: {session_id} Entities: {json.dumps(entities)}"\n        embedding = self.model.encode(context_text)\n        \n        self.qdrant.upsert(\n            collection_name="conversation_context",\n            points=[{\n                "id": session_id,\n                "vector": embedding,\n                "payload": {\n                    "session_id": session_id,\n                    "extracted_entities": entities,\n                    "pending_fields": pending_fields,\n                    "api_endpoint": api_endpoint\n                }\n            }]\n        )\n    \n    def get_context(self, session_id):\n        """Retrieve conversation context"""\n        results = self.qdrant.scroll(\n            collection_name="conversation_context",\n            scroll_filter={\n                "must": [{"key": "session_id", "match": {"value": session_id}}]\n            }\n        )\n        \n        if results[0]:\n            return results[0][0].payload\n        return None\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-api-schema-validator",children:"3. API Schema Validator"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class APIValidator:\n    def __init__(self, api_schemas):\n        self.schemas = api_schemas\n    \n    def validate_request(self, entities, schema):\n        """Validate if all required fields are present"""\n        missing_fields = []\n        \n        for field in schema["required_fields"]:\n            if field not in entities:\n                missing_fields.append(field)\n        \n        return missing_fields\n    \n    def get_field_options(self, field_name, schema):\n        """Get available options for a field"""\n        return schema.get("field_options", {}).get(field_name, [])\n    \n    def build_request_body(self, entities, schema):\n        """Build API request body from entities"""\n        request_body = {}\n        \n        # Add required fields\n        for field in schema["required_fields"]:\n            if field in entities:\n                request_body[field] = entities[field]\n        \n        # Add optional fields if present\n        for field in schema["optional_fields"]:\n            if field in entities:\n                request_body[field] = entities[field]\n        \n        return request_body\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-itsm-api-client",children:"4. ITSM API Client"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import requests\n\nclass ITSMClient:\n    def __init__(self, base_url, auth_token):\n        self.base_url = base_url\n        self.headers = {\n            "Authorization": f"Bearer {auth_token}",\n            "Content-Type": "application/json"\n        }\n    \n    def create_ticket(self, request_body):\n        """Create ITSM ticket via API"""\n        try:\n            response = requests.post(\n                f"{self.base_url}/api/tickets",\n                json=request_body,\n                headers=self.headers\n            )\n            \n            if response.status_code == 201:\n                return {"success": True, "data": response.json()}\n            else:\n                return {\n                    "success": False, \n                    "error": response.json().get("message", "Unknown error")\n                }\n        \n        except requests.exceptions.RequestException as e:\n            return {"success": False, "error": str(e)}\n    \n    def get_field_options(self, field_name):\n        """Get available options for a field"""\n        try:\n            response = requests.get(\n                f"{self.base_url}/api/fields/{field_name}/options",\n                headers=self.headers\n            )\n            \n            if response.status_code == 200:\n                return response.json().get("options", [])\n            return []\n        \n        except requests.exceptions.RequestException:\n            return []\n'})}),"\n",(0,s.jsx)(n.h3,{id:"5-conversation-handler",children:"5. Conversation Handler"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class ConversationHandler:\n    def __init__(self):\n        self.intent_extractor = IntentExtractor()\n        self.context_manager = ContextManager(self.intent_extractor.qdrant)\n        self.validator = APIValidator(self._load_api_schemas())\n        self.itsm_client = ITSMClient("https://itsm-api.company.com", "your_token")\n    \n    def handle_query(self, user_query, session_id):\n        """Main conversation handler"""\n        # Extract intent and entities\n        intent_result = self.intent_extractor.extract_intent(user_query, session_id)\n        \n        if not intent_result:\n            return "I couldn\'t understand your request. Please try again."\n        \n        # Get or create context\n        context = self.context_manager.get_context(session_id) or {}\n        \n        # Merge entities with existing context\n        all_entities = {**context.get("extracted_entities", {}), **intent_result["entities"]}\n        \n        # Validate required fields\n        missing_fields = self.validator.validate_request(all_entities, intent_result["schema"])\n        \n        if missing_fields:\n            return self._ask_for_missing_fields(missing_fields, session_id, all_entities, intent_result)\n        \n        # All fields present, create ticket\n        return self._create_ticket(all_entities, intent_result["schema"], session_id)\n    \n    def _ask_for_missing_fields(self, missing_fields, session_id, entities, intent_result):\n        """Ask user for missing required fields"""\n        # Save context\n        self.context_manager.save_context(\n            session_id, entities, missing_fields, intent_result["api_endpoint"]\n        )\n        \n        field = missing_fields[0]\n        options = self.validator.get_field_options(field, intent_result["schema"])\n        \n        if options:\n            options_text = ", ".join(options)\n            return f"Please select {field} from: {options_text}"\n        else:\n            return f"Please provide {field}:"\n    \n    def _create_ticket(self, entities, schema, session_id):\n        """Create ticket and handle response"""\n        request_body = self.validator.build_request_body(entities, schema)\n        \n        # Confirm with user before creating\n        return f"Would you like me to create a ticket with these details?\\n" \\\n               f"Issue: {entities.get(\'description\', \'N/A\')}\\n" \\\n               f"Type: {entities.get(\'issue_type\', \'N/A\')}\\n" \\\n               f"Priority: {entities.get(\'priority\', \'Medium\')}\\n\\n" \\\n               f"Reply \'yes\' to confirm."\n    \n    def confirm_ticket_creation(self, session_id):\n        """Handle ticket creation confirmation"""\n        context = self.context_manager.get_context(session_id)\n        \n        if not context:\n            return "Session expired. Please start again."\n        \n        schema = self._get_schema_by_endpoint(context["api_endpoint"])\n        request_body = self.validator.build_request_body(context["extracted_entities"], schema)\n        \n        result = self.itsm_client.create_ticket(request_body)\n        \n        if result["success"]:\n            ticket_id = result["data"].get("ticket_id")\n            return f"\u2705 Ticket created successfully! Ticket ID: {ticket_id}"\n        else:\n            return f"\u274c Error creating ticket: {result[\'error\']}"\n    \n    def _load_api_schemas(self):\n        """Load API schemas - simplified example"""\n        return {\n            "create_ticket": {\n                "endpoint": "/api/tickets",\n                "method": "POST",\n                "required_fields": ["description", "issue_type"],\n                "optional_fields": ["priority", "assignee"],\n                "field_options": {\n                    "issue_type": ["hardware", "software", "network", "printer"],\n                    "priority": ["low", "medium", "high", "urgent"]\n                }\n            }\n        }\n    \n    def _get_schema_by_endpoint(self, endpoint):\n        """Get schema by endpoint"""\n        schemas = self._load_api_schemas()\n        for schema in schemas.values():\n            if schema["endpoint"] == endpoint:\n                return schema\n        return None\n'})}),"\n",(0,s.jsx)(n.h2,{id:"implementation-steps",children:"Implementation Steps"}),"\n",(0,s.jsx)(n.h3,{id:"step-1-setup-vector-database",children:(0,s.jsx)(n.strong,{children:"Step 1: Setup Vector Database"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Initialize Qdrant collections"}),"\n",(0,s.jsx)(n.li,{children:"Load API schemas into vector store"}),"\n",(0,s.jsx)(n.li,{children:"Create embeddings for schema matching"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-2-implement-core-functions",children:(0,s.jsx)(n.strong,{children:"Step 2: Implement Core Functions"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Intent extraction with entity recognition"}),"\n",(0,s.jsx)(n.li,{children:"Context management for multi-turn conversations"}),"\n",(0,s.jsx)(n.li,{children:"API validation and request building"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-3-integration--testing",children:(0,s.jsx)(n.strong,{children:"Step 3: Integration & Testing"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Connect to ITSM API endpoints"}),"\n",(0,s.jsx)(n.li,{children:"Test conversation flows"}),"\n",(0,s.jsx)(n.li,{children:"Handle edge cases and errors"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"step-4-optimization",children:(0,s.jsx)(n.strong,{children:"Step 4: Optimization"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Implement caching for frequently accessed data"}),"\n",(0,s.jsx)(n.li,{children:"Optimize vector search parameters"}),"\n",(0,s.jsx)(n.li,{children:"Add human-in-the-loop confirmation steps"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-conversation-flow",children:"Example Conversation Flow"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"User"}),': "My printer is not working"']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"System"}),': "I\'d like to help you create a ticket. Please select the issue type from: hardware, software, network, printer"']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"User"}),': "printer"']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"System"}),': "Would you like me to create a ticket with these details?']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Issue: My printer is not working"}),"\n",(0,s.jsx)(n.li,{children:"Type: printer"}),"\n",(0,s.jsx)(n.li,{children:"Priority: Medium"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Reply 'yes' to confirm.\""}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"User"}),': "yes"']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"System"}),': "\u2705 Ticket created successfully! Ticket ID: INC-2024-001"']}),"\n",(0,s.jsx)(n.p,{children:"This solution provides a minimal yet comprehensive approach to NLP-driven API integration, optimizing token usage while maintaining functionality through smart context management and vector-based storage."})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);